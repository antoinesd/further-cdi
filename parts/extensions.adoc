[.intro]
== Introducing CDI Portable Extensions

[.topic.source]
== Portable extensions

[.statement]
====

ifdef::includegifs[]
image::powerful.gif[role="pull-right", width="270"]
endif::includegifs[]

NOTE: One of the _most powerful feature_ of the CDI specification

NOTE: Not really popularized, partly due to:

. Their _high level of abstraction_
. The good knowledge on Basic CDI and SPI
. Lack of information (CDI is often reduced to a basic DI solution)
====


[.topic.source]
== Extensions, what for?

[.statement]
====

TIP: To integrate 3rd party libraries, frameworks or legacy components

TIP: To change existing configuration or behavior

TIP: To extend CDI and Java EE

TIP: Thanks to them, Java EE can evolve between major releases

====


[.topic.source]
== Extensions, how?

[.statement]
====

ifdef::includegifs[]
image::rubik.gif[role="pull-right", width="250"]
endif::includegifs[]

TIP: Observing SPI events at boot time related to the bean manager lifecycle

TIP: Checking what meta-data are being created

TIP: Modifying these meta-data or creating new ones

====


[.topic.source]
== More concretely

NOTE: Service provider of the service `javax.enterprise.inject.spi.Extension` declared in `META-INF/services`

TIP: Just put the fully qualified name of your extension class in this file

[source, subs="verbatim,quotes", role="smaller"]
----
import javax.enterprise.event.Observes;
import javax.enterprise.inject.spi.Extension;

public class CdiExtension [highlight]#implements Extension# {

    void beforeBeanDiscovery([highlight]#@Observes BeforeBeanDiscovery# bbd) {
    }
    //...

    void afterDeploymentValidation([highlight]#@Observes AfterDeploymentValidation# adv) {
    }
}
----


[.topic.source]
== Bean manager lifecycle

[plantuml, "lifecycle-simple", "svg", height="85%", width="95%"]
----
@startuml

skinparam shadowing false
skinparam backgroundColor transparent
skinparam defaultFontName Consolas

skinparam activity {
  BackgroundColor #337788
  BackgroundColor<< Internal >> #888888
  BackgroundColor<< Once >> #BB3322
  ArrowColor #888888
  BarColor #888888
  BorderColor White
  FontName Consolas
  FontColor White
  FontSize 20
}

(*) -right-> "Deployment\nStart" << Internal >>
-right-> "Before\nBean\nDiscovery" << Once >>
-right-> "Scan\nArchive" << Internal >>
-right-> "Process\nAnnotated\nType"
-right-> "After\nType\nDiscovery" << Once >>
-down-> "Bean\nEligibility\nCheck" << Internal >>
-left-> "Process\nInjection\nPoint"
-left-> "Process\nInjection\nTarget"
-left-> "Process\nBean\nAttributes"
-down-> "Process\nBean"
-right-> "Process\nProducer"
-right-> "Process\nObserver\nMethod"
-right-> "After\nBean\nDiscovery" << Once >>
-down-> "After\nDeployment\nValidation" << Once >>
-left-> "Application\nRunning" << Internal >>
-left-> "Before\nShutdown" << Once >>
-left-> "Undeploy\nApplication" << Internal >>
-left-> (*)

@enduml
----

[plantuml, "lifecycle-legend", "svg", height="40", width="230", role="pull-right"]
----
@startuml

skinparam shadowing false
skinparam backgroundColor transparent
skinparam defaultFontName Consolas

skinparam activity {
  StartColor white
  BackgroundColor #337788
  BackgroundColor<< Internal >> #888888
  BackgroundColor<< Once >> #BB3322
  ArrowColor white
  BarColor #888888
  BorderColor White
  FontName Consolas
  FontColor White
  FontSize 20
}

(*) -down-> "Internal Step" << Internal >>
-right-> "Happen Once" <<Once>>
-right-> "Loop on Elements"

@enduml
----


[.topic.source]
== Example: Ignoring JPA entities

TIP: The following extension prevents CDI to manage entities

NOTE: This is a commonly admitted good practice

[source, role="smaller"]
----
public class VetoEntity implements Extension {

  void noEntity(@Observes @WithAnnotations(Entity.class) ProcessAnnotatedType<?> p) {
      p.veto();
  }
}
----

////

[.topic.source]
== Example: Register a Bean from an annotation 1/4

TIP: To integrate MongoDB with CDI we want to provide a way to write this:

[source]
----
@MongoClientDefinition(name = "myMongo", url = "mongodb://localhost")
public class AnyClass {
}
----
TIP: and have the corresponding `Mongoclient` produced so we can inject it:

[source]
----
public class MyService {
  @Inject
  MongoClient myclient;
}
----
TIP: In the same spirit than `@DataSourceDefinition`

[.topic.source]
== Example: Register a Bean from an annotation 2/4

TIP: Rather standard annotation code:

[source]
----
@Target(value = {TYPE})
@Retention(value = RUNTIME)
@Documented
public @interface MongoClientDefinition
{
  String name();
  String description() default "";
  String url() default "";
}
----

[.topic.source]
== Example: Register a Bean from an annotation 3/4

[source.smallest]
----
public class MongoExtension implements Extension {
  private MongoClientDefinition mongoDef = null;
  void detectMongoClientDefinition(
    @Observes @WithAnnotations(MongoClientDefinition.class) ProcessAnnotatedType<?> pat) {
      AnnotatedType at = pat.getAnnotatedType();
      mongoDef = at.getAnnotation(MongoClientDefinition.class);
  }

  void registerDataSourceBeans(@Observes AfterBeanDiscovery abd, BeanManager bm) {
    MongoClientURI uri = new MongoClientURI(mongoDef.url());
    abd.addBean(bm.createBean(new MongoClientBeanAttributes(bm.createBeanAttributes(bm.createAnnotatedType
      (MongoClient.class))), MongoClient.class, new MongoClientProducerFactory(uri)));
  }

  private static class MongoClientBeanAttributes implements BeanAttributes<MongoClient> {
    private BeanAttributes<MongoClient> delegate;
    MongoClientBeanAttributes(BeanAttributes<MongoClient> beanAttributes) {
      delegate = beanAttributes;
    }
    public Class<? extends Annotation> getScope() {
      return ApplicationScoped.class;
    }
    //skiping delegating methods
  }
...
----

[.topic.source]
== Example: Register a Bean from an annotation 4/4

[source.smallest]
----
...
  private static class MongoClientProducerFactory implements InjectionTargetFactory<MongoClient> {
    MongoClientURI uri;
    MongoClientProducerFactory(MongoClientURI uri) {
      this.uri = uri;
    }

    public InjectionTarget<MongoClient> createInjectionTarget(Bean<MongoClient> bean) {
      return new InjectionTarget<MongoClient>() {

        public MongoClient produce(CreationalContext<MongoClient> ctx) {
          try {
            return new MongoClient(uri);
            } catch (UnknownHostException e) {
              throw new IllegalArgumentException(e);
            }
          }
          public void dispose(MongoClient instance) {
            instance.close();
          }
          // skipping empty methods
        };
      }
    }
}
----

////

[.topic.recap]
== Remember

icon:warning[] Extensions are _launched during +
  bootstrap_ and are _based on CDI events_

icon:warning[] Once the application is bootstrapped, +
  the Bean Manager is in _read-only mode_ (no runtime bean registration)

icon:warning[] You only have to `@Observes` _built-in CDI events_ to create your extensions
